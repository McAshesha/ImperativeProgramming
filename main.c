#include <stdio.h>
#include <stdlib.h>

// Задаём максимальные параметры: число вершин (MAXN) и число рёбер (MAXM).
// При необходимости можно увеличить в зависимости от ограничений задачи.
#define MAXN 10000
#define MAXM 100000

// Структуры для представления списка смежности.
// Мы храним два массива ребёр (двунаправленные): to[] ? назначение ребра, nxt[] ? ссылка на следующее ребро из той же вершины.
// head[u] хранит индекс первого ребра, исходящего из вершины u.
// ecnt ? счетчик добавленных полурёбер (т.к. каждое ребро фактически добавляется дважды для неориентированного графа).
int head[MAXN + 1];
int to[2 * MAXM + 1];
int nxt[2 * MAXM + 1];
int ecnt = 0;

// Добавление неориентированного ребра u?v в список смежности:
// 1) Добавляем ?полуребро? u -> v.
// 2) Затем добавляем ?полуребро? v -> u.
void add_edge(int u, int v) {
    // Добавляем ребро u -> v
    ecnt++;                    // увеличиваем глобальный счётчик рёбер
    to[ecnt] = v;              // назначение этого ребра ? вершина v
    nxt[ecnt] = head[u];       // ?следующее? ребро из u ? это предыдущее первое из u
    head[u] = ecnt;            // теперь этим ребром начинается список смежности у

    // Добавляем ребро v -> u (для симметрии неориентированного графа)
    ecnt++;
    to[ecnt] = u;
    nxt[ecnt] = head[v];
    head[v] = ecnt;
}

// Вспомогательный массив queue[] служит очередью для обхода в ширину (BFS).
int queue[MAXN + 1];

int main() {
    int n, m;
    // Считываем из входа число вершин n и число рёбер m.
    // Ожидаем, что вершины пронумерованы от 1 до n.
    scanf("%d %d", &n, &m);

    // Инициализируем структуру списка смежности:
    // для каждой вершины i делаем head[i] = 0 (список пуст).
    for (int i = 1; i <= n; i++) {
        head[i] = 0;
    }
    ecnt = 0;  // сбрасываем счётчик рёбер

    // Считываем m рёбер и добавляем их в список смежности.
    // Каждая строка содержит пару u, v.
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(u, v);
    }

    // Переменная diameter будет хранить текущий максимум кратчайших расстояний.
    int diameter = 0;

    // Массив dist[] будет хранить расстояния от текущей начальной вершины до всех остальных.
    // Выделяем динамически, чтобы не захламлять стек большим массивом.
    int *dist = (int*)malloc((n + 1) * sizeof(int));

    // Для каждой вершины start (от 1 до n) запускаем BFS,
    // чтобы найти все кратчайшие расстояния от неё до остальных вершин.
    for (int start = 1; start <= n; start++) {
        // 1) Инициализация: помечаем все вершины как ?не посещённые? (dist = -1).
        for (int i = 1; i <= n; i++) {
            dist[i] = -1;
        }
        // Расстояние до самой себя равно 0.
        dist[start] = 0;

        // 2) Инициализация очереди BFS.
        int qh = 0, qt = 0;    // qh ? индекс головы очереди, qt ? хвоста
        queue[qt++] = start;   // помещаем стартовую вершину в очередь

        int local_max = 0;     // локальный максимум расстояний от вершины start

        // 3) Основной цикл BFS: пока очередь не пуста, достаём вершину u и обрабатываем её соседей.
        while (qh < qt) {
            int u = queue[qh++];         // извлекаем из очереди
            // Проходим по всем рёбрам, исходящим из u.
            for (int e = head[u]; e; e = nxt[e]) {
                int v = to[e];           // получаем смежную вершину
                if (dist[v] == -1) {     // если ещё не посещали
                    dist[v] = dist[u] + 1;   // обновляем расстояние
                    // Обновляем локальный максимум, если нужно.
                    if (dist[v] > local_max) {
                        local_max = dist[v];
                    }
                    queue[qt++] = v;     // добавляем v в очередь для дальнейшей обработки
                }
            }
        }

        // 4) После завершения BFS проверяем: все ли вершины достижимы?
        // Если нет (dist[i] == -1), значит граф несвязный ? диаметр = бесконечность ? выводим -1 и выходим.
        for (int i = 1; i <= n; i++) {
            if (dist[i] == -1) {
                printf("-1\n");
                free(dist);
                return 0;
            }
        }

        // 5) Обновляем глобальный диаметр: если локальный максимум от start больше предыдущего, заменяем.
        if (local_max > diameter) {
            diameter = local_max;
        }
    }

    // Освобождаем динамически выделенную память.
    free(dist);

    // 6) Выводим окончательный результат ? диаметр графа.
    printf("%d\n", diameter);
    return 0;
}
